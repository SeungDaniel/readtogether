아래 내용 그대로 복붙해서 **Codex/클로드/기타 개발 모델에게 던져도 되는 수준**으로 쓸게.

(v1: 웹훅 없음, **폴링 + cron + 오라클 서버** 기준)

---

# 요한복음 데일리 텔레그램 봇 – 개발 지시서 v1

(폴링 + cron + 구글 시트 연동 버전)

---

## 0. 프로젝트 목표 (요약)

**목표:**

요한복음 읽기 로드맵을 기반으로,

1. **공동체 단톡방**에는 매일 정해진 시간에 “오늘의 본문”을 자동으로 보내고,
2. **개인 1:1 채팅**에서는 각자가 `/next`를 눌러 **자기 페이스로 퀘스트처럼** 진도를 진행할 수 있는 텔레그램 봇을 만든다.

**전제 조건:**

* 서버: 사용자는 **Oracle Cloud Ubuntu 서버 1대**를 가지고 있다.
* 통신 방식: **웹훅(HTTPS/443) 사용하지 않는다.**
  * 대신:
    * **cron**으로 매일 한 번 실행되는 스크립트 (단체방 데일리 발송)
    * **긴 폴링(getUpdates)** 으로 명령 처리하는 상시 실행 스크립트 (개인 1:1 모드)

---

## 1. 전체 아키텍처

### 1.1 구성 요소

1. **텔레그램 봇**
   * BotFather에서 생성한 `BOT_TOKEN` 사용
2. **오라클 서버**
   * Python 3.x
   * cron 사용 가능
   * 상시 실행되는 폴링 스크립트 1개
3. **구글 스프레드시트**
   * 하나의 스프레드시트 안에 **두 개의 시트(sheet)** 사용
     1. `plan_sheet` : 요한복음 읽기 플랜
     2. `progress_sheet` : 사용자별 개인 진도 기록
   * Google Service Account + Google Sheets API로 접근

### 1.2 데이터 흐름 요약

* **공동체 모드(단톡방)**
  1. cron → `daily_broadcast.py` 실행
  2. `daily_broadcast.py` → `plan_sheet`에서 `day`에 해당하는 한 줄 읽음
  3. `daily_broadcast.py` → 텔레그램 `GROUP_CHAT_ID`에 오늘 본문 메시지 전송
* **개인 모드(1:1 DM)**
  1. `bot_polling.py` 가 텔레그램 `getUpdates`로 새 메시지 폴링
  2. `/start_john`, `/next`, `/status`, `/repeat` 등의 명령 처리
  3. `progress_sheet`에서 해당 사용자 `current_day` 읽고/쓰기
  4. `plan_sheet`에서 그 day의 본문 정보 가져와서 사용자에게 전송

---

## 2. 구글 시트 구조

하나의 스프레드시트(`<SPREADSHEET_ID>`) 안에 아래 두 시트를 전제로 한다.

### 2.1 plan_sheet (요한복음 읽기 플랜)

* 시트 이름 예: `plan`
* 헤더는 1행에, 실제 데이터는  **2행부터** .

| 컬럼 | 이름    | 타입   | 설명                              |
| ---- | ------- | ------ | --------------------------------- |
| A    | day     | int    | 1, 2, 3… (읽기 일차, 고유 키)    |
| B    | ref     | string | “요 1:1-18” 같은 본문 범위      |
| C    | title   | string | 소제목 (예: “빛으로 오신 말씀”) |
| D    | summary | string | 3줄 이내 본문 요약                |

> v1에서는 `batch`(하루 2세트 발송 여부)는  **사용하지 않음** . 추후 확장 가능.

---

### 2.2 progress_sheet (사용자별 진도)

* 시트 이름 예: `progress`
* 헤더는 1행에, 실제 데이터는  **2행부터** .

| 컬럼 | 이름         | 타입   | 설명                                                                 |
| ---- | ------------ | ------ | -------------------------------------------------------------------- |
| A    | user_id      | string | 텔레그램 user id (또는 chat_id –**1:1 채팅의 chat_id 사용** ) |
| B    | username     | string | 텔레그램 username (@없이) / 없을 경우 빈 문자열                      |
| C    | current_day  | int    | 다음에 읽을 DAY 번호 (처음 시작 시 1)                                |
| D    | last_read_at | string | 마지막으로 퀘스트를 진행한 날짜(YYYY-MM-DD), 없으면 빈 문자열        |

* **키:**
  * `user_id`(또는 1:1 `chat_id`)를 기준으로 한 사람당 1행만 존재한다고 가정.

---

## 3. 환경 설정

### 3.1 환경 변수 (서버)

다음 값을 **환경변수** 또는 `.env` / `config.py` 등에서 관리한다.

* `TELEGRAM_BOT_TOKEN` : BotFather에서 받은 봇 토큰
* `TELEGRAM_GROUP_CHAT_ID` : 공동체 단톡방 chat_id (정수 또는 문자열)
* `GOOGLE_SERVICE_ACCOUNT_FILE` : 서비스 계정 JSON 파일의 경로 (서버 내부 경로)
* `SPREADSHEET_ID` : 요한복음 플랜/진도 시트가 담긴 구글 스프레드시트 ID
* `PLAN_SHEET_NAME` : 플랜 시트 이름 (예: `"plan"`)
* `PROGRESS_SHEET_NAME` : 진도 시트 이름 (예: `"progress"`)
* `START_DATE` : 공동체 DAY 1이 시작되는 날짜 (예: `"2025-12-01"`)

### 3.2 사용 라이브러리 (Python)

* `requests` : 텔레그램 API 호출용 (혹은 python-telegram-bot 대체 가능)
* `google-api-python-client`
* `google-auth`
* `google-auth-httplib2`

필요하면:

```bash
pip install requests google-api-python-client google-auth google-auth-httplib2
```

---

## 4. 기능 요구사항 – 공동체 모드 (방 전체)

### 4.1 daily_broadcast.py – 오늘 본문 자동 발송 스크립트

#### 4.1.1 역할

* 매일 정해진 시간(예: 오전 8시)에 **cron으로 실행**된다.
* `START_DATE` 기준으로 “오늘이 몇 일차인지” 계산한다.
* `plan_sheet`에서 해당 `day` 행을 읽어온다.
* 텔레그램의 `TELEGRAM_GROUP_CHAT_ID`로 메시지를 전송한다.

#### 4.1.2 로직 상세

1. `START_DATE`(문자열) → `datetime.date`로 파싱.
2. `today = datetime.date.today()` (서버 로컬 시간 사용; 한국 기준 맞추고 싶으면 타임존 보정 고려)
3. `day_index = (today - START_DATE).days`
4. `if day_index < 0: 종료` (아직 시작 전)
5. `day = day_index + 1`
6. 구글 시트 `plan_sheet`에서 `day` 열이 `day`와 일치하는 행을 찾아 `ref`, `title`, `summary`를 가져온다.
   * 못 찾으면: 로그에 경고 남기고 프로그램 종료 (텔레그램에는 아무 것도 보내지 않음 – v1에서 OK)
7. 아래 포맷으로 메시지 텍스트 구성:
   ```text
   [공동체 DAY {day}] 오늘 함께 읽을 범위 안내

   오늘 읽을 범위는 {ref} ({title}) 입니다.

   📖 이런 내용입니다:
   {summary}

   읽고 퀴즈를 내거나, 인상깊은 구절을 공유하는 등 자유롭게 인증해주세요. 🙌
   ```
8. 텔레그램 `sendMessage` API로 전송:
   * URL: `https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage`
   * 파라미터: `chat_id=TELEGRAM_GROUP_CHAT_ID`, `text=msg`

#### 4.1.3 cron 설정 (참고용, 코드에는 포함 X)

* 예: 매일 8시에 실행

```cron
0 8 * * * /usr/bin/python3 /home/ubuntu/daily_broadcast.py >> /home/ubuntu/john_daily.log 2>&1
```

---

## 5. 기능 요구사항 – 개인 퀘스트 모드 (1:1 채팅)

### 5.1 bot_polling.py – 폴링 기반 명령 처리 봇

#### 5.1.1 역할

* **웹훅을 사용하지 않고** , 텔레그램 `getUpdates`를 일정 주기로 호출해 **새 메시지를 폴링**한다.
* 새 메시지가 오면,
  * **개인 1:1 채팅(private)**에서만 다음 명령들을 처리:
    * `/start_john`
    * `/next`
    * `/status`
    * `/repeat`
* 공동체 방(group/supergroup) 메시지는 v1에서는 무시해도 됨.

#### 5.1.2 폴링 구조 요구사항

* `offset` 값을 관리해서, 같은 메시지를 중복 처리하지 않는다.
* 기본 루프:
  1. `getUpdates` 호출 (timeout = 10~30초 정도의 long polling)
  2. 응답에 `result` 배열이 있으면, 각 update에 대해:
     * `update_id` 확인
     * `message` 또는 `edited_message` 중 `message`만 처리
     * `chat.type == "private"` 인 경우만 명령 처리
  3. 처리 후 `offset = max(update_id) + 1` 로 갱신
  4. 무한 루프 (KeyboardInterrupt 등으로 종료 가능)

#### 5.1.3 명령별 동작

**공통: private chat인 경우만 처리**

---

##### (1) `/start_john`

* 목적: 개인 퀘스트 플랜 초기화/시작

**로직:**

1. `chat_id`를 `user_id`로 사용 (1:1 채팅 기준).
2. `progress_sheet`에서 `user_id`와 일치하는 행을 찾는다.
3. 없다면:
   * 새 행 추가:
     * `user_id` = chat_id
     * `username` = message에서 username 가져오되 없으면 빈 문자열
     * `current_day` = 1
     * `last_read_at` = 빈 문자열 또는 오늘 날짜
   * 사용자에게 안내 메시지:
     ```text
     요한복음 데일리 퀘스트를 시작합니다. ✨
     지금부터 당신의 속도로, 1일차부터 차근차근 함께 읽을게요.

     - /next : 다음 퀘스트(다음 본문) 받기
     - /repeat : 방금 퀘스트 다시 보기
     - /status : 내 진행 현황 보기

     지금은 1일차부터 시작할 수 있어요.
     /next 를 입력해 첫 퀘스트를 받아보세요.
     ```
4. 이미 행이 있다면:
   * `current_day`를 읽고, 아래와 같이 안내:
     ```text
     이미 요한복음 퀘스트를 진행 중입니다. 😊

     - 현재 진행 단계: DAY {current_day}
     - /next : 다음 퀘스트 받기
     - /status : 내 진행 현황 보기
     - /repeat : 마지막 퀘스트 다시 보기
     ```

---

##### (2) `/next`

* 목적: “현재 나의 next 퀘스트” 본문을 받아보기

**로직:**

1. `progress_sheet`에서 `user_id`(=chat_id) 조회
2. 없으면:
   * 마치 `/start_john`을 안 한 상태이므로,
     * “먼저 /start_john 으로 퀘스트를 시작해주세요.” 메시지 전송 후 종료.
3. 있으면:
   * `current_day`를 읽음 → `day`
4. `plan_sheet`에서 `day`에 해당하는 행을 찾는다.
   * 없으면: “더 이상 준비된 퀘스트가 없습니다. 축하합니다, 완주하셨습니다!” 같은 메시지 전송 후 종료.
5. 본문 구성:
   ```text
   [개인 DAY {day}] {ref} ({title})

   📖 이런 내용입니다:
   {summary}

   인상 깊은 구절이나 한 줄 소감을 보내주셔도 좋습니다.
   다음 퀘스트는 /next 로 계속 이어갈 수 있어요.
   ```
6. 메시지 전송 후:
   * `current_day`를 `day + 1`로 업데이트
   * `last_read_at`를 오늘 날짜(YYYY-MM-DD)로 업데이트
   * 이 업데이트는 `progress_sheet`의 해당 행에 반영

---

##### (3) `/status`

* 목적: “내가 지금 어디까지 왔는지” 확인

**로직:**

1. `progress_sheet`에서 `user_id` 조회
2. 없으면:
   * “아직 요한복음 퀘스트를 시작하지 않으셨습니다. /start_john 으로 시작할 수 있어요.” 전송
3. 있으면:
   * `current_day`를 읽음
   * `next_day = current_day`
   * `finished_day = current_day - 1` (0 이하가 되면 0으로 조정)
   * `plan_sheet`에서 `next_day`의 `ref`, `title`를 시도해본다 (없으면 “더 이상 남은 퀘스트 없음”으로 처리)
   * 응답 메시지 예:
     ```text
     🔎 나의 요한복음 퀘스트 현황

     - 완료한 퀘스트: DAY {finished_day}
     - 다음 퀘스트: DAY {next_day} – {ref} ({title})
     ```
   * 만약 `next_day`에 해당하는 행이 없다면:
     ```text
     이미 준비된 모든 퀘스트를 완료하셨습니다. 🎉
     수고 많으셨어요!
     ```

---

##### (4) `/repeat`

* 목적: 마지막으로 읽었던 퀘스트(=current_day - 1)를 다시 보고 싶을 때

**로직:**

1. `progress_sheet`에서 `user_id` 조회
2. 없으면:
   * `/status`와 동일하게 “아직 시작 안 함” 안내
3. 있으면:
   * `current_day`를 읽고 `repeat_day = current_day - 1`
   * `repeat_day <= 0`이면:
     * “아직 완료한 퀘스트가 없습니다. /next 로 첫 퀘스트를 받아보세요.” 메시지
   * `plan_sheet`에서 `repeat_day`의 행을 찾아 `ref`, `title`, `summary` 읽음
   * 메시지 구성:
     ```text
     [마지막으로 읽은 DAY {repeat_day}] {ref} ({title})

     📖 이런 내용입니다:
     {summary}

     이 본문을 다시 묵상해도 좋고,
     준비가 되었다면 /next 로 다음 퀘스트로 넘어갈 수 있어요.
     ```

---

## 6. 구현 가이드 (파일 구조 제안)

아래는 개발 모델이 참고할 수 있는 **파일 구조 예시**다. 필수는 아니지만, 이렇게 나누면 보기 좋다.

```text
project_root/
  config.py
  google_sheets_client.py
  plan_repository.py
  progress_repository.py
  daily_broadcast.py
  bot_polling.py
  requirements.txt
```

### 6.1 config.py

* 환경변수 로딩 및 공통 설정 정의

```python
import os
import datetime

TELEGRAM_BOT_TOKEN = os.environ["TELEGRAM_BOT_TOKEN"]
TELEGRAM_GROUP_CHAT_ID = os.environ["TELEGRAM_GROUP_CHAT_ID"]

GOOGLE_SERVICE_ACCOUNT_FILE = os.environ["GOOGLE_SERVICE_ACCOUNT_FILE"]
SPREADSHEET_ID = os.environ["SPREADSHEET_ID"]
PLAN_SHEET_NAME = os.environ.get("PLAN_SHEET_NAME", "plan")
PROGRESS_SHEET_NAME = os.environ.get("PROGRESS_SHEET_NAME", "progress")

START_DATE_STR = os.environ.get("START_DATE", "2025-12-01")
START_DATE = datetime.datetime.strptime(START_DATE_STR, "%Y-%m-%d").date()
```

### 6.2 google_sheets_client.py

* 서비스 계정 JSON으로 인증하고,
  * `get_values(range)`
  * `append_row(...)`
  * `update_row(...)`

    같은 헬퍼 함수 제공.

### 6.3 plan_repository.py

* 기능:
  * `get_plan_by_day(day: int) -> dict | None`
* 내부에서:
  * `PLAN_SHEET_NAME!A2:D` 범위를 읽고,
  * `day` 열과 매칭되는 행을 dict로 반환.

### 6.4 progress_repository.py

* 기능:
  * `get_progress(user_id: str) -> dict | None`
  * `create_or_update_progress(user_id: str, username: str, current_day: int, last_read_at: str)`
* 내부 구현은:
  * `PROGRESS_SHEET_NAME!A2:D` 범위에서 `user_id` 찾고,
  * 없으면 새 행 append,
  * 있으면 해당 행 update.

### 6.5 daily_broadcast.py

* 4장에서 설명한 로직 구현.

### 6.6 bot_polling.py

* 5장에서 설명한 폴링 + 명령 처리 구현.

---

## 7. v1 범위 정리

**v1에서 반드시 구현해야 할 기능:**

1. plan_sheet, progress_sheet의 구조대로 구글 시트 연동
2. `daily_broadcast.py` – cron으로 그룹방에 오늘 본문 발송
3. `bot_polling.py` – getUpdates 폴링 기반:
   * `/start_john`
   * `/next`
   * `/status`
   * `/repeat`

**v1에서 안 해도 되는 것(향후 확장):**

* 인라인 버튼 (`✅ 오늘 퀘스트 완료`)
* `/today_group` 처럼 개인 DM에서 공동체 오늘 본문 조회
* 오랜 기간 접속 없는 사용자 리마인드
* 통계/리더보드
* 여러 플랜(요한복음 외) 지원
* 웹훅/HTTPS/443 설정

---

이 지시서를 그대로 Codex/클로드에게:

> “아래 개발지시서에 맞춰,
>
> `google_sheets_client.py`, `plan_repository.py`, `progress_repository.py`, `daily_broadcast.py`, `bot_polling.py`를 순서대로 구현해줘.”

라고 던지면, 꽤 좋은 v1 코드 뼈대를 뽑아줄 거야.

필요하면 다음 단계로, **실제 코드 초안**도 같이 짜보자.
